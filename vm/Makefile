#!/usr/bin/make -f

CC=				gcc
CFLAGS_OPT?=    -O2 -g -pipe
CFLAGS_STD?=    -std=c11
CFLAGS_WARN?=   -Wall -W -Wextra -Wpedantic

CFLAGS?=    	${CFLAGS_OPT}
CFLAGS+=    	${CFLAGS_STD} ${CFLAGS_WARN}

CFLAGS+=   		-Werror
CFLAGS+=		-Wbad-function-cast -Wcast-align -Wcast-qual -Wchar-subscripts \
				-Winline -Wmissing-prototypes -Wnested-externs -Wpointer-arith \
				-Wredundant-decls -Wshadow -Wstrict-prototypes -Wwrite-strings

CPPFLAGS_STD?=	-D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=700
CPPFLAGS+=		${CPPFLAGS_STD}

RM?=        	rm -f

BUILD_DIR=		build/

PROG=			vm
OBJS=			main.o debug.o utils.o

SRCS=			main.c

# Build rule first creates the .o files
# all rule then moves them to the build dir.
# I think this is a pretty nice way to have a build
# dir using implicit rules (the ones at the bottom)
all: 			build
				mkdir -p build
				mv ${PROG} *.o ${BUILD_DIR}

build:			${PROG}

${PROG}:		${OBJS}
				${CC} ${LDFLAGS} -o ${PROG} ${OBJS}

clean:
				${RM} -r ${BUILD_DIR}

.PHONY: all clean

# DO NOT EDIT
# Generated by gcc -MM *.c
# Info on gcc -MM: https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html

# Implicit rules. Make knows how go build .o files
debug.o: debug.c debug.h common.h bytecode.h
main.o: main.c bytecode.h common.h debug.h utils.h
utils.o: utils.c utils.h common.h	
